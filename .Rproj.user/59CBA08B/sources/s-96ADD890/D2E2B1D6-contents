functions {
  // POWER GENERALIZED WEIBULL
  
  // Hazard Function
  vector hazPGW (int N_cens, vector t_cens, real eta, real nu, real theta) { // Computed for censored times only with NO log-transformation.
    vector[N_cens] res;
    for (i in 1:N_cens) {
      res[i] = nu / (theta * pow(eta, nu)) * pow(t_cens[i], (nu - 1)) * pow(1 + pow((t_cens[i] / eta), nu), ((1 / theta) - 1));
      // res[i] = log(nu) - log(theta) - nu * log(eta) + (nu - 1) * log(t_cens[i]) + ((1 / theta) - 1) * log(1 + pow(t_cens[i] / eta, nu));
    }
    
    return res;
  }
  
  // Cumulative Hazard Function
  vector cumHazPGW (int N_unce, int N_cens, vector t_unce, vector t_cens, real eta, real nu, real theta) { // Computed for all data.
    vector[(N_unce + N_cens)] res;
    for (i in 1:N_unce) {
      res[i] = - 1 + pow(1 + pow((t_unce[i] / eta), nu), (1 / theta));
    }
    for (i in 1:N_cens) {
      res[N_unce + i] = - 1 + pow(1 + pow((t_cens[i] / eta), nu), (1 / theta));
    }
    
    return res;
  }
  
  // Linear Predictor for the non-baseline function
  vector linear_predictor (int N_unce, int N_cens, matrix X_unce, matrix X_cens, vector betas) {
    vector[(N_unce + N_cens)] res;
    
    res[1:N_unce] = X_unce * betas; // Might have problems due to the diference between array and vector.
    res[(N_unce + 1): (N_unce + N_cens)] =  X_cens * betas;
    
    return res;
  }
}

data {
  int<lower = 1> N;
  int<lower = 0> M;
  int<lower = 0> N_unce;
  int<lower = 0> N_cens;
  vector<lower = 0>[N_unce] t_unce;
  vector<lower = 0>[N_cens] t_cens;
  vector<lower = 0>[N_unce] p_hazU;
  vector<lower = 0>[N_cens] p_hazC;
  matrix[N_unce, M] X_unce;
  matrix[N_cens, M] X_cens;
  // Still missing information about the adjacency matrix.
}

parameters {
  vector[M] betas;
  
  real<lower=0> eta;
  real<lower=0> nu;
  real<lower=0> theta; // Check the constraints.
}

model {
  // Priors for parameters and hyperparameters
  
  betas ~ normal(0, 3); // Improve it. Maybe, separating the intercept.
  eta ~ normal(0, 3);
  nu ~ normal(0, 3);
  theta ~ normal(0, 3); // Change it for better priors.
  
  // Log-likelihood
  
  {
    vector[N_cens] cens_like;
    vector[N_unce + N_cens] allt_like;
    vector[N_unce + N_cens] linearPRE;
    
    linearPRE = linear_predictor(N_unce, N_cens, X_unce, X_cens, betas);
    cens_like = log(hazPGW(N_cens, t_cens, eta, nu, theta) .* exp(linearPRE[(N_unce + 1):(N_unce + N_cens)]) + p_hazC);
    allt_like = cumHazPGW(N_unce, N_cens, t_unce, t_cens, eta, nu, theta) .* exp(linearPRE);
    
    target += sum(cens_like) - sum(allt_like);
  }
}
