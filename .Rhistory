if (distribution == "LN") {
excHaz[, i, j] <- hazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "LL") {
excHaz[, i, j] <- hazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "PGW") {
excHaz[, i, j] <- hazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = fitted_data$theta[i], log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = fitted_data$theta[i]) * exp(lp - lp_tilde)
} else {
stop("Choose a valid distribution.")
}
netSur[, i, j] <- exp(- excCumHaz[, i, j])
if (verbose) { setTxtProgressBar(progressbar, i) }
}
if (verbose) { close(progressbar) }
}
list(excHaz = excHaz, excCumHaz = excCumHaz, netSur = netSur)
}
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X, spatial = spatial)
result_processing <- function (model, fitted_data, N_samples, N_reg, distribution, time, X_tilde, X, spatial = F, verbose = T, ...) {
m_tilde <- check_n_cov(var = fitted_data$alpha)
m <- check_n_cov(var = fitted_data$beta)
if ((ncol(X_tilde) != m_tilde) | (ncol(X) != m)) {
stop("Provide the correct values for covariates.")
}
if (!spatial) {
N_reg <- 1
}
excHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
excCumHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
netSur <- array(data = 0, dim = c(length(time), N_samples, N_reg))
for (j in 1:N_reg) {
if (verbose) {
cat(ifelse(test = spatial, yes = paste("\nRegion ", sprintf('%02d', j), "\n", sep = ""), no = "\nALL\n"))
progressbar <- txtProgressBar(min = 1, max = N_samples, initial = 1)
}
for (i in 1:N_samples) {
lp_tilde <- compute_lp(m = m_tilde, X = X_tilde, coeff = fitted_data$alpha[i, ])
lp <- compute_lp(m = m, X = X, coeff = fitted_data$beta[i, ])
part <- add_re(model = model, lp_tilde = lp_tilde, lp = lp, random_effects = c(fitted_data$u_tilde[i, j], fitted_data$u[i, j]))
lp_tilde <- part$lp_re_tilde
lp <- part$lp_re
if (distribution == "LN") {
excHaz[, i, j] <- hazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "LL") {
excHaz[, i, j] <- hazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "PGW") {
excHaz[, i, j] <- hazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = fitted_data$theta[i], log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = fitted_data$theta[i]) * exp(lp - lp_tilde)
} else {
stop("Choose a valid distribution.")
}
netSur[, i, j] <- exp(- excCumHaz[, i, j])
if (verbose) { setTxtProgressBar(progressbar, i) }
}
if (verbose) { close(progressbar) }
}
list(excHaz = excHaz, excCumHaz = excCumHaz, netSur = netSur)
}
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X, spatial = spatial)
result_processing <- function (model, fitted_data, N_samples, N_reg, distribution, time, X_tilde, X, spatial = F, verbose = T, ...) {
m_tilde <- check_n_cov(var = fitted_data$alpha)
m <- check_n_cov(var = fitted_data$beta)
if ((ncol(X_tilde) != m_tilde) | (ncol(X) != m)) {
stop("Provide the correct values for covariates.")
}
if (!spatial) {
N_reg <- 1
}
excHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
excCumHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
netSur <- array(data = 0, dim = c(length(time), N_samples, N_reg))
for (j in 1:N_reg) {
if (verbose) {
cat(ifelse(test = spatial, yes = paste("\nRegion ", sprintf('%02d', j), "\n", sep = ""), no = "ALL\n"))
progressbar <- txtProgressBar(min = 1, max = N_samples, initial = 1)
}
for (i in 1:N_samples) {
lp_tilde <- compute_lp(m = m_tilde, X = X_tilde, coeff = fitted_data$alpha[i, ])
lp <- compute_lp(m = m, X = X, coeff = fitted_data$beta[i, ])
part <- add_re(model = model, lp_tilde = lp_tilde, lp = lp, random_effects = c(fitted_data$u_tilde[i, j], fitted_data$u[i, j]))
lp_tilde <- part$lp_re_tilde
lp <- part$lp_re
if (distribution == "LN") {
excHaz[, i, j] <- hazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "LL") {
excHaz[, i, j] <- hazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "PGW") {
excHaz[, i, j] <- hazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = fitted_data$theta[i], log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = fitted_data$theta[i]) * exp(lp - lp_tilde)
} else {
stop("Choose a valid distribution.")
}
netSur[, i, j] <- exp(- excCumHaz[, i, j])
if (verbose) { setTxtProgressBar(progressbar, i) }
}
if (verbose) { close(progressbar) }
}
list(excHaz = excHaz, excCumHaz = excCumHaz, netSur = netSur)
}
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X, spatial = spatial)
excHaz <- res$excHaz
str(excHaz)
excHaz
dim(excHaz)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
region <- 1
plot_summary_curve(time = time, obj = excHaz, region = region, ylab = "Excess Hazard", distribution = distribution, spatial = spatial, return_values = T)
region <- 2
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = time, obj = excHaz, region = region, ylab = "Excess Hazard", distribution = distribution, spatial = spatial, return_values = T)
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = time, obj = excHaz, region = region, ylab = "Excess Hazard", distribution = distribution, spatial = spatial, return_values = T)
plot_all_regions <- function (time, obj, N_reg, ylab = "Net Survival", distribution = "PGW", pos_legend = "topright", return_values = F, ...) {
meanCurves <- apply(X = obj, MARGIN = c(1, 3), FUN = mean)
plot(NA, xlim = c(0, max(time)), ylim = c(0, max(meanCurves)), xlab = "Time", ylab = ylab, main = paste("All regions (", distribution, ")", sep = ""))
for (j in 1:N_reg) {
lines(time, meanCurves[, j], col = j)
}
legend(x = pos_legend, inset = 0.01, legend = paste("Region ", sprintf('%02d', c(1:N_reg)), sep = ""), col = 1:N_reg, lty = 1, box.lty = 0, cex = 0.5)
p <- recordPlot()
if (return_values) { return(list(plot = p, meanCurves = meanCurves)) }
}
region <- 2
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = time, obj = excHaz, region = region, ylab = "Excess Hazard", distribution = distribution, spatial = spatial, return_values = T)
plot_summary_curve
plot_summary_curve <- function (time, obj, region, ylab = "Net Survival", distribution = "PGW", spatial = T, return_values = F, ...) {
if (!spatial) {
region = 1
}
M <- apply(X = obj[, , region], MARGIN = c(1), FUN = mean)
L <- apply(X = obj[, , region], MARGIN = c(1), FUN = quantile, prob = c(0.025))
U <- apply(X = obj[, , region], MARGIN = c(1), FUN = quantile, prob = c(0.975))
plot(NA, xlim = c(0, max(time)), ylim = c(0, max(U)), xlab = "Time", ylab = ylab, main = ifelse(test = spatial, yes = paste("Region ", sprintf('%02d', region), "(", distribution, ")", sep = ""), no = paste("ALL (", distribution, ")", sep = "")))
polygon(x = c(time, rev(time)), y = c(L, rev(U)), col = rgb(red = 0, green = 0, blue = 0, alpha = 0.1), border = F)
lines(x = time, y = M, col = rgb(red = 0.1, green = 0.1, blue = 0.1), lty = 2)
lines(x = time, y = L, col = rgb(red = 0.1, green = 0.1, blue = 0.1), lty = 1)
lines(x = time, y = U, col = rgb(red = 0.1, green = 0.1, blue = 0.1), lty = 1)
p <- recordPlot()
if (return_values) { return(list(plot = p, M = M, L = L, U = U)) }
}
plot_summary_curve
region <- 2
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = time, obj = excHaz, region = region, ylab = "Excess Hazard", distribution = distribution, spatial = spatial, return_values = T)
plot_summary_curve <- function (time, obj, region = 1, ylab = "Net Survival", distribution = "PGW", spatial = T, return_values = F, ...) {
if (!spatial) {
region = 1
}
M <- apply(X = obj[, , region], MARGIN = c(1), FUN = mean)
L <- apply(X = obj[, , region], MARGIN = c(1), FUN = quantile, prob = c(0.025))
U <- apply(X = obj[, , region], MARGIN = c(1), FUN = quantile, prob = c(0.975))
plot(NA, xlim = c(0, max(time)), ylim = c(0, max(U)), xlab = "Time", ylab = ylab, main = ifelse(test = spatial, yes = paste("Region ", sprintf('%02d', region), "(", distribution, ")", sep = ""), no = paste("ALL (", distribution, ")", sep = "")))
polygon(x = c(time, rev(time)), y = c(L, rev(U)), col = rgb(red = 0, green = 0, blue = 0, alpha = 0.1), border = F)
lines(x = time, y = M, col = rgb(red = 0.1, green = 0.1, blue = 0.1), lty = 2)
lines(x = time, y = L, col = rgb(red = 0.1, green = 0.1, blue = 0.1), lty = 1)
lines(x = time, y = U, col = rgb(red = 0.1, green = 0.1, blue = 0.1), lty = 1)
p <- recordPlot()
if (return_values) { return(list(plot = p, M = M, L = L, U = U)) }
}
source("header.R")
compute_loo <- function (stanfit, ...) {
log_lik <- extract_log_lik(stanfit = stanfit, merge_chains = F)
r_eff <- relative_eff(exp(log_lik), cores = getOption(x = "mc.cores", default = detectCores()))
loo <- loo(x = log_lik, r_eff = r_eff, cores = getOption(x = "mc.cores", default = detectCores()))
loo
}
plot_ind_curves <- function (res, N_reg, time, distribution, spatial = T, ...) {
if (!spatial) {
N_reg <- 1
}
res_excHaz <- list(); res_excCumHaz <- list(); res_netSur <- list();
for (i in 1:N_reg) {
res_excHaz[[i]]    <- plot_summary_curve(time = time, obj = res$excHaz,    region = i, ylab = "Excess Hazard", distribution = distribution, spatial = spatial, return_values = T)
res_excCumHaz[[i]] <- plot_summary_curve(time = time, obj = res$excCumHaz, region = i, ylab = "Excess Cumulative Hazard", distribution = distribution, spatial = spatial, return_values = T)
res_netSur[[i]]    <- plot_summary_curve(time = time, obj = res$netSur,    region = i, distribution = distribution, spatial = spatial, return_values = T)
}
list(res_excHaz = res_excHaz, res_excCumHaz = res_excCumHaz, res_netSur = res_netSur)
}
plot_all_curves <- function (time, res, N_reg, distribution, ...) {
excHaz    <- plot_all_regions(time = time, obj = res$excHaz,    N_reg = N_reg, ylab = "Excess Hazard", distribution = distribution, return_values = T)
excCumHaz <- plot_all_regions(time = time, obj = res$excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", distribution = distribution, pos_legend = "topleft", return_values = T)
netSur    <- plot_all_regions(time = time, obj = res$netSur,    N_reg = N_reg, distribution = distribution, return_values = T)
list(excHaz = excHaz, excCumHaz = excCumHaz, netSur = netSur)
}
model <- 6
N_reg <- 24
spatial <- ifelse(test = N_reg <= 5, yes = T, no = F)
fit_PGW <- readRDS(file = paste("FITTED_MODELS/PGW/PGW", model, ".rds", sep = "")); fitted_data_PGW <- extract(fit_PGW)
fit_LN  <- readRDS(file = paste("FITTED_MODELS/LN/LN"  , model, ".rds", sep = "")); fitted_data_LN  <- extract(fit_LN )
fit_LL  <- readRDS(file = paste("FITTED_MODELS/LL/LL"  , model, ".rds", sep = "")); fitted_data_LL  <- extract(fit_LL )
print(fit_PGW, pars = c("log_lik"), include = F)
print(fit_LN , pars = c("log_lik"), include = F)
print(fit_LL , pars = c("log_lik"), include = F)
# `loo`
(loo_PGW <- compute_loo(stanfit = fit_PGW))
(loo_LN  <- compute_loo(stanfit = fit_LN ))
(loo_LL  <- compute_loo(stanfit = fit_LL ))
(loo_result <- loo_compare(list(PGW = loo_PGW, LN = loo_LN, LL = loo_LL)))
# Bridge for 'Bayes factor'
bridge_PGW <- readRDS(file = paste("FITTED_MODELS/PGW/bridge_PGW", model, ".rds", sep = ""))
bridge_LN  <- readRDS(file = paste("FITTED_MODELS/LN/bridge_LN"  , model, ".rds", sep = ""))
bridge_LL  <- readRDS(file = paste("FITTED_MODELS/LL/bridge_LL"  , model, ".rds", sep = ""))
(bf_PGW_LN <- bayes_factor(x1 = bridge_PGW, x2 = bridge_LN))
(bf_PGW_LL <- bayes_factor(x1 = bridge_PGW, x2 = bridge_LL))
(bf_LN_LL  <- bayes_factor(x1 = bridge_LN , x2 = bridge_LL))
(loo_result <- loo_compare(list(PGW = loo_PGW, LN = loo_LN, LL = loo_LL)))
?compare
compare(loo_PGW, loo_LL)
source("header.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
spatial <- ifelse(test = N_reg <= 5, yes = T, no = F)
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("age", "sex", "wbc", "dep"), adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "LL" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 4e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
seed = seed,
pars = c("lp_tilde", "lp", "excessHaz", "cumExcessHaz"),
include = F,
control = list(adapt_delta = 0.80, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
# fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
### Assess Fitted Model
print(fit, pars = c("log_lik"), include = F)
pairs(x = fit, pars = c("log_lik", "energy__", "lp__"), include = F) # log = T
par <- fitted_data$mu
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
## Model Comparison
# "loo"
log_lik <- extract_log_lik(stanfit = fit, merge_chains = F)
r_eff <- relative_eff(exp(log_lik), cores = getOption(x = "mc.cores", default = detectCores()))
loo <- loo(x = log_lik, r_eff = r_eff, cores = getOption(x = "mc.cores", default = detectCores()))
print(loo)
# loo_compare(list("M1" = loo1, "M2" = loo2))
# "Bayes factor"
bridge <- bridge_sampler(samples = fit, cores = getOption(x = "mc.cores", default = detectCores()), silent = T)
saveRDS(object = bridge, file = paste("FITTED_MODELS/", distribution, "/bridge_", distribution, model, ".rds", sep = ""))
source("header.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
spatial <- ifelse(test = N_reg <= 5, yes = T, no = F)
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("age", "sex", "wbc", "dep"), adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "LL" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 4e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
pars = c("lp_tilde", "lp", "excessHaz", "cumExcessHaz"),
include = F,
control = list(adapt_delta = 0.80, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
# fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
### Assess Fitted Model
print(fit, pars = c("log_lik"), include = F)
pairs(x = fit, pars = c("log_lik", "energy__", "lp__"), include = F) # log = T
par <- fitted_data$mu
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
## Model Comparison
# "loo"
log_lik <- extract_log_lik(stanfit = fit, merge_chains = F)
r_eff <- relative_eff(exp(log_lik), cores = getOption(x = "mc.cores", default = detectCores()))
loo <- loo(x = log_lik, r_eff = r_eff, cores = getOption(x = "mc.cores", default = detectCores()))
print(loo)
# loo_compare(list("M1" = loo1, "M2" = loo2))
# "Bayes factor"
bridge <- bridge_sampler(samples = fit, cores = getOption(x = "mc.cores", default = detectCores()), silent = T)
saveRDS(object = bridge, file = paste("FITTED_MODELS/", distribution, "/bridge_", distribution, model, ".rds", sep = ""))
source("header.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
spatial <- ifelse(test = N_reg <= 5, yes = T, no = F)
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("age", "sex", "wbc", "dep"), adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "LN" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 4e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
pars = c("lp_tilde", "lp", "excessHaz", "cumExcessHaz"),
include = F,
control = list(adapt_delta = 0.80, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
# fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
### Assess Fitted Model
print(fit, pars = c("log_lik"), include = F)
pairs(x = fit, pars = c("log_lik", "energy__", "lp__"), include = F) # log = T
par <- fitted_data$mu
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
## Model Comparison
# "loo"
log_lik <- extract_log_lik(stanfit = fit, merge_chains = F)
r_eff <- relative_eff(exp(log_lik), cores = getOption(x = "mc.cores", default = detectCores()))
loo <- loo(x = log_lik, r_eff = r_eff, cores = getOption(x = "mc.cores", default = detectCores()))
print(loo)
# loo_compare(list("M1" = loo1, "M2" = loo2))
# "Bayes factor"
bridge <- bridge_sampler(samples = fit, cores = getOption(x = "mc.cores", default = detectCores()), silent = T)
saveRDS(object = bridge, file = paste("FITTED_MODELS/", distribution, "/bridge_", distribution, model, ".rds", sep = ""))
# bf <- bayes_factor(x1 = bridge1, x2 = bridge2)
source("header.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
spatial <- ifelse(test = N_reg <= 5, yes = T, no = F)
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("age", "sex", "wbc", "dep"), adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "PGW" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 4e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
pars = c("lp_tilde", "lp", "excessHaz", "cumExcessHaz"),
include = F,
control = list(adapt_delta = 0.80, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
# fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
### Assess Fitted Model
print(fit, pars = c("log_lik"), include = F)
pairs(x = fit, pars = c("log_lik", "energy__", "lp__"), include = F) # log = T
par <- fitted_data$mu
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
## Model Comparison
# "loo"
log_lik <- extract_log_lik(stanfit = fit, merge_chains = F)
r_eff <- relative_eff(exp(log_lik), cores = getOption(x = "mc.cores", default = detectCores()))
loo <- loo(x = log_lik, r_eff = r_eff, cores = getOption(x = "mc.cores", default = detectCores()))
print(loo)
# loo_compare(list("M1" = loo1, "M2" = loo2))
# "Bayes factor"
bridge <- bridge_sampler(samples = fit, cores = getOption(x = "mc.cores", default = detectCores()), silent = T)
saveRDS(object = bridge, file = paste("FITTED_MODELS/", distribution, "/bridge_", distribution, model, ".rds", sep = ""))
# bf <- bayes_factor(x1 = bridge1, x2 = bridge2)
source("header.R")
compute_loo <- function (stanfit, ...) {
log_lik <- extract_log_lik(stanfit = stanfit, merge_chains = F)
r_eff <- relative_eff(exp(log_lik), cores = getOption(x = "mc.cores", default = detectCores()))
loo <- loo(x = log_lik, r_eff = r_eff, cores = getOption(x = "mc.cores", default = detectCores()))
loo
}
plot_ind_curves <- function (res, N_reg, time, distribution, spatial = T, ...) {
if (!spatial) {
N_reg <- 1
}
res_excHaz <- list(); res_excCumHaz <- list(); res_netSur <- list();
for (i in 1:N_reg) {
res_excHaz[[i]]    <- plot_summary_curve(time = time, obj = res$excHaz,    region = i, ylab = "Excess Hazard", distribution = distribution, spatial = spatial, return_values = T)
res_excCumHaz[[i]] <- plot_summary_curve(time = time, obj = res$excCumHaz, region = i, ylab = "Excess Cumulative Hazard", distribution = distribution, spatial = spatial, return_values = T)
res_netSur[[i]]    <- plot_summary_curve(time = time, obj = res$netSur,    region = i, distribution = distribution, spatial = spatial, return_values = T)
}
list(res_excHaz = res_excHaz, res_excCumHaz = res_excCumHaz, res_netSur = res_netSur)
}
plot_all_curves <- function (time, res, N_reg, distribution, ...) {
excHaz    <- plot_all_regions(time = time, obj = res$excHaz,    N_reg = N_reg, ylab = "Excess Hazard", distribution = distribution, return_values = T)
excCumHaz <- plot_all_regions(time = time, obj = res$excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", distribution = distribution, pos_legend = "topleft", return_values = T)
netSur    <- plot_all_regions(time = time, obj = res$netSur,    N_reg = N_reg, distribution = distribution, return_values = T)
list(excHaz = excHaz, excCumHaz = excCumHaz, netSur = netSur)
}
### START HERE
model <- 6
N_reg <- 24
spatial <- ifelse(test = N_reg <= 5, yes = T, no = F)
###
fit_PGW <- readRDS(file = paste("FITTED_MODELS/PGW/PGW", model, ".rds", sep = "")); fitted_data_PGW <- extract(fit_PGW)
fit_LN  <- readRDS(file = paste("FITTED_MODELS/LN/LN"  , model, ".rds", sep = "")); fitted_data_LN  <- extract(fit_LN )
fit_LL  <- readRDS(file = paste("FITTED_MODELS/LL/LL"  , model, ".rds", sep = "")); fitted_data_LL  <- extract(fit_LL )
print(fit_PGW, pars = c("log_lik"), include = F)
print(fit_LN , pars = c("log_lik"), include = F)
print(fit_LL , pars = c("log_lik"), include = F)
# `loo`
(loo_PGW <- compute_loo(stanfit = fit_PGW))
(loo_LN  <- compute_loo(stanfit = fit_LN ))
(loo_LL  <- compute_loo(stanfit = fit_LL ))
(loo_result <- loo_compare(list(PGW = loo_PGW, LN = loo_LN, LL = loo_LL)))
# Bridge for 'Bayes factor'
bridge_PGW <- readRDS(file = paste("FITTED_MODELS/PGW/bridge_PGW", model, ".rds", sep = ""))
bridge_LN  <- readRDS(file = paste("FITTED_MODELS/LN/bridge_LN"  , model, ".rds", sep = ""))
bridge_LL  <- readRDS(file = paste("FITTED_MODELS/LL/bridge_LL"  , model, ".rds", sep = ""))
(bf_PGW_LN <- bayes_factor(x1 = bridge_PGW, x2 = bridge_LN))
(bf_PGW_LL <- bayes_factor(x1 = bridge_PGW, x2 = bridge_LL))
(bf_LN_LL  <- bayes_factor(x1 = bridge_LN , x2 = bridge_LL))
### VISUALIZATION
par(family = 'LM Roman 10', mfrow = c(1, 1))
N_samples <- length(fitted_data_PGW$lp__)
time <- seq(from = 0.025, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1.5), nrow = length(time), ncol = 1, byrow = T)
X <- matrix(data = c(1.5, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res_PGW <- result_processing(model = model, fitted_data = fitted_data_PGW, N_samples = N_samples, N_reg = N_reg, distribution = "PGW", time = time, X_tilde = X_tilde, X = X)
res_LN  <- result_processing(model = model, fitted_data = fitted_data_LN , N_samples = N_samples, N_reg = N_reg, distribution = "LN" , time = time, X_tilde = X_tilde, X = X)
res_LL  <- result_processing(model = model, fitted_data = fitted_data_LL , N_samples = N_samples, N_reg = N_reg, distribution = "LL" , time = time, X_tilde = X_tilde, X = X)
res_plot_PGW <- plot_ind_curves(res = res_PGW, N_reg = N_reg, time = time, distribution = "PGW", spatial = spatial)
res_plot_LN  <- plot_ind_curves(res = res_LN , N_reg = N_reg, time = time, distribution = "LN" , spatial = spatial)
res_plot_LL  <- plot_ind_curves(res = res_LL , N_reg = N_reg, time = time, distribution = "LL" , spatial = spatial)
if (spatial) {
all_curves_PGW <- plot_all_curves(time = time, res = res_PGW, N_reg = N_reg, distribution = "PGW")
all_curves_LN  <- plot_all_curves(time = time, res = res_LN , N_reg = N_reg, distribution = "LN" )
all_curves_LL  <- plot_all_curves(time = time, res = res_LL , N_reg = N_reg, distribution = "LL" )
}
# Draw maps
?loo_compare
fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
model <- 6
distribution <- "PGW" # PGW, LN, or LL
fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
# "loo"
log_lik <- extract_log_lik(stanfit = fit, merge_chains = F)
r_eff <- relative_eff(exp(log_lik), cores = getOption(x = "mc.cores", default = detectCores()))
loo <- loo(x = log_lik, r_eff = r_eff, cores = getOption(x = "mc.cores", default = detectCores()))
print(loo)
