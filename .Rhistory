seed <- 1
chains <- 4
iter <- 4e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""), # Check the covariates part
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.80),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "PGW" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 4e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""), # Check the covariates part
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.80),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "PGW" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 4e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""), # Check the covariates part
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.80),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
mean(fitted_data$alpha[, 1])
mean(fitted_data$alpha[, 2])
mean(fitted_data$beta[, 1])
mean(fitted_data$beta[, 1])
mean(fitted_data$beta[, 2])
mean(fitted_data$beta[, 3])
mean(fitted_data$beta[, 4])
mean(fitted_data$beta[, 5])
mean(fitted_data$log_eta)
mean(fitted_data$log_theta)
mean(fitted_data$log_nu)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 10
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
result_processing
compute_lp
lp <- compute_lp(m = m, X = X, coeff = fitted_data$beta[i, ])
result_processing <- function (model, fitted_data, N_samples, N_reg, distribution, time, X_tilde, X, verbose = T, ...) {
m_tilde <- check_n_cov(var = fitted_data$alpha)
m <- check_n_cov(var = fitted_data$beta)
if ((ncol(X_tilde) != m_tilde) | (ncol(X) != m)) {
stop("Provide the correct values for covariates.")
}
excHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
excCumHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
netSur <- array(data = 0, dim = c(length(time), N_samples, N_reg))
for (j in 1:N_reg) {
if (verbose) {
cat(paste("\nRegion ", sprintf('%02d', j), "\n", sep = ""))
progressbar <- txtProgressBar(min = 1, max = N_samples, initial = 1)
}
for (i in 1:N_samples) {
lp_tilde <- compute_lp(m = m_tilde, X = X_tilde, coeff = fitted_data$alpha[i, ])
lp <- compute_lp(m = m, X = X, coeff = fitted_data$beta[i, ])
part <- add_re(model = model, lp_tilde = lp_tilde, lp = lp, random_effects = c(fitted_data$u_tilde[i, j], fitted_data$u[i, j]))
lp_tilde <- part$lp_re_tilde
lp <- part$lp_re
if (distribution == "LN") {
excHaz[, i, j] <- hazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = fitted_data$sigma[i], log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = fitted_data$sigma[i]) * exp(lp - lp_tilde)
} else if (distribution == "LL") {
excHaz[, i, j] <- hazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = fitted_data$sigma[i], log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = fitted_data$sigma[i]) * exp(lp - lp_tilde)
} else if (distribution == "PGW") {
excHaz[, i, j] <- hazPGW(N = length(time), time = time * exp(lp_tilde), eta = fitted_data$eta[i], nu = fitted_data$nu[i], theta = fitted_data$theta[i], log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazPGW(N = length(time), time = time * exp(lp_tilde), eta = fitted_data$eta[i], nu = fitted_data$nu[i], theta = fitted_data$theta[i]) * exp(lp - lp_tilde)
} else {
stop("Choose a valid distribution.")
}
netSur[, i, j] <- exp(- excCumHaz[, i, j])
if (verbose) { setTxtProgressBar(progressbar, i) }
}
if (verbose) { close(progressbar) }
}
list(excHaz = excHaz, excCumHaz = excCumHaz, netSur = netSur)
}
compute_lp <- function (m, X, coeff, ...) {
if (m != 0) {
lp <- X %*% coeff
} else {
lp <- as.matrix(rep(x = 0, times = nrow(X)))
}
lp
}
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
region <- 10
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
model <- 1
fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
# Result Processing
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
par
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
n_iter <- (iter - warmup) / chains
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
par
par <- fitted_data$alpha[, 1]
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
n_iter <- (iter - warmup) / chains
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
for (i in 1:chains) {
lines(x = par[((i - 1) * n_iter + 1):(n_iter * i)], col = i)
}
p <- recordPlot()
n_iter
iter
warmup
plot_chains <- function (par, chains, iter, warmup) {
n_iter <- (iter - warmup)
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
for (i in 1:chains) {
lines(x = par[((i - 1) * n_iter + 1):(n_iter * i)], col = i)
}
p <- recordPlot()
p
}
n_iter <- (iter - warmup)
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
for (i in 1:chains) {
lines(x = par[((i - 1) * n_iter + 1):(n_iter * i)], col = i)
}
legend(x = "bottomright", inset = 0.01, legend = paste("Chain ", c(1:chains), sep = ""), col = 1:chains, lty = 1, box.lty = 0, cex = 0.5)
legend(x = "bottomright", inset = 0.01, legend = paste("Chain ", c(1:chains), sep = ""), col = 1:chains, lty = 1, box.lty = 0, cex = 0.75)
legend(x = "bottomright", inset = 0.01, legend = paste("Chain ", c(1:chains), sep = ""), col = 1:chains, lty = 1, box.lty = 1, cex = 0.75)
legend(x = "bottomright", inset = 0, legend = paste("Chain ", c(1:chains), sep = ""), col = 1:chains, lty = 1, box.lty = 1, cex = 0.75)
plot_chains <- function (par, chains, iter, warmup) {
n_iter <- (iter - warmup)
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
for (i in 1:chains) {
lines(x = par[((i - 1) * n_iter + 1):(n_iter * i)], col = i)
}
legend(x = "bottomright", inset = 0, legend = paste("Chain ", c(1:chains), sep = ""), col = 1:chains, lty = 1, box.lty = 1, cex = 0.75)
p <- recordPlot()
p
}
plot_chains <- function (par, chains, iter, warmup) {
n_iter <- (iter - warmup)
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
for (i in 1:chains) {
lines(x = par[((i - 1) * n_iter + 1):(n_iter * i)], col = i)
}
legend(x = "bottomright", inset = 0, legend = paste("Chain ", c(1:chains), sep = ""), col = 1:chains, lty = 1, box.lty = 1, cex = 0.75)
p <- recordPlot()
p
}
par <- fitted_data$beta[, 4]
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
par <- fitted_data$beta[, 4]
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
par <- fitted_data$theta
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
par <- fitted_data$log_theta
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
plot_chains <- function (par, chains, iter, warmup) {
n_iter <- (iter - warmup)
plot(x = NA, xlim = c(1, n_iter), ylim = c(min(par), max(par)), xlab = "Iterations", ylab = "Parameter")
for (i in 1:chains) {
lines(x = par[((i - 1) * n_iter + 1):(n_iter * i)], col = i)
}
legend(x = "bottomright", inset = 0, legend = paste("Chain ", sprintf('%02d', c(1:chains)), sep = ""), col = 1:chains, lty = 1, box.lty = 1, cex = 0.75)
p <- recordPlot()
p
}
par <- fitted_data$log_theta
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
plot_all_regions <- function (time, obj, N_reg, ylab = "Net Survival", pos_legend = "topright", return_values = F, ...) {
meanCurves <- apply(X = obj, MARGIN = c(1, 3), FUN = mean)
plot(NA, xlim = c(0, max(time)), ylim = c(0, max(meanCurves)), xlab = "Time", ylab = ylab, main = "All regions")
for (j in 1:N_reg) {
lines(time, meanCurves[, j], col = j)
}
legend(x = pos_legend, inset = 0.01, legend = paste("Region ", sprintf('%02d', c(1:N_reg)), sep = ""), col = 1:N_reg, lty = 1, box.lty = 0, cex = 0.5)
p <- recordPlot()
if (return_values) { return(list(plot = p, meanCurves = meanCurves)) }
}
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
par <- fitted_data$log_theta
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "LN" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 80e3
warmup <- 75e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""), # Check the covariates part
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.80),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
par <- fitted_data$log_theta
par <- fitted_data$log_sigma
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "LN" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 50e3
warmup <- 480e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""), # Check the covariates part
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.90),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "LN" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 50e3
warmup <- 48e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""), # Check the covariates part
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.90),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, model = model)
str(d)
### Stan Modeling
distribution <- "LN" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 50e3
warmup <- 48e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""), # Check the covariates part
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.90),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
par <- fitted_data$log_sigma
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
par <- fitted_data$mu
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
par <- fitted_data$sigma
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
par <- fitted_data$beta[,1]
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
par <- fitted_data$beta[, 2]
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
summary(fit)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
region <- 2
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
