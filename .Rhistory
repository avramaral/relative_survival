map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 100
warmup <- 50
str(d)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 100
warmup <- 50
start_time <- Sys.time()
fit <- stan(file = paste(distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.99),
cores = getOption(x = "mc.cores", default = detectCores()))
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 4000
warmup <- 3000
start_time <- Sys.time()
fit <- stan(file = paste(distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.99),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- rstan::extract(fit)
fitted_data$eta
mean(fitted_data$eta)
plot(fitted_data$eta, type = 'l')
plot(fitted_data$theta, type = 'l')
plot(fitted_data$nu, type = 'l')
plot(fitted_data$log_nu, type = 'l')
mean(fitted_data$log_nu, type = 'l')
mean(fitted_data$log_theta, type = 'l')
mean(fitted_data$log_eta, type = 'l')
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 7
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
rstan:::rstudio_stanc("PGW/PGW7.stan")
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 7
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 1000
warmup <- 500
start_time <- Sys.time()
fit <- stan(file = paste(distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.99),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
str(d)
fitted_data <- rstan::extract(fit)
mean(fitted_data$eta)
mean(fitted_data$theta)
mean(fitted_data$log_eta)
mean(fitted_data$log_theta)
mean(fitted_data$log_nu)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 8
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 8
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 1000
warmup <- 500
start_time <- Sys.time()
fit <- stan(file = paste(distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.99),
cores = getOption(x = "mc.cores", default = detectCores()))
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 8
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 4000
warmup <- 3000
start_time <- Sys.time()
fit <- stan(file = paste(distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.99),
cores = getOption(x = "mc.cores", default = detectCores()))
fitted_data <- rstan::extract(fit)
mean(fitted_data$log_eta)
mean(fitted_data$log_theta)
mean(fitted_data$log_nu)
rstan:::rstudio_stanc("PGW/PGW9.stan")
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 9
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 9
d <- data_stan(data = data, model = model, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 4000
warmup <- 3000
start_time <- Sys.time()
fit <- stan(file = paste(distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.99),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
# saveRDS(object = fit, file = paste("DATA/", distribution, model, ".rds", sep = ""))
# fit <- readRDS(file = paste("DATA/", distribution, model, ".rds", sep = ""))
fitted_data <- rstan::extract(fit)
head(data)
d <- data_stan(data = data, model = model, cov_tilde = c("age", "sex", "wbc", "dep"), cov = c("age", , "sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
data_stan
d <- data_stan(data = data, model = model, cov_tilde = c("age", "sex", "wbc", "dep"), cov = c("age", "sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
str(d)
X_tilde
d$X_tilde
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 9
d <- data_stan(data = data, model = model, cov_tilde = c("age", "sex", "wbc", "dep"), cov = c("age", "sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
str(d)
### Stan Modeling
distribution <- "PGW"
seed <- 1
chains <- 2
iter <- 4000
warmup <- 3000
start_time <- Sys.time()
fit <- stan(file = paste(distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.99),
cores = getOption(x = "mc.cores", default = detectCores()))
fitted_data <- rstan::extract(fit)
fitted_data$log_nu
plot(fitted_data$log_nu, type = 'l')
plot(fitted_data$log_theta, type = 'l')
plot(fitted_data$log_eta, type = 'l')
mean(fitted_data$log_eta)
mean(fitted_data$log_theta)
mean(fitted_data$log_nu)
plot(fitted_data$alpha[, 1], type = 'l')
plot(fitted_data$alpha[, 2], type = 'l')
plot(fitted_data$alpha[, 3], type = 'l')
plot(fitted_data$alpha[, 4], type = 'l')
plot(fitted_data$alpha[, 5], type = 'l')
pairs(fit)
pairs(fit)
pairs(fit)
pairs(fit)[1:2]
pairs(fit)[1]
fit <- readRDS(file = paste("FITTED_MODELS/", distribution, model, ".rds", sep = ""))
model <- 1
fit <- readRDS(file = paste("FITTED_MODELS/", distribution, model, ".rds", sep = ""))
fitted_data <- rstan::extract(fit)
distribution
get(distribution)
get(paste("cumHaz", distributionsep = ""))
get(paste("cumHaz", distribution, sep = ""))
### Power Generalized Weibull (PGW)
# Hazard Function PGW
hazPGW <- function (N, time, eta, nu, theta, log = T) {
res <- c()
for (i in 1:N) {
res <- c(res, log(nu) - log(theta) - nu * log(eta) + (nu - 1) * log(time[i]) + ((1 / theta) - 1) * log(1 + (time[i] / eta) ^ nu))
}
if (log) {
return(res)
} else {
return(exp(res))
}
}
# Cumulative Hazard Function PGW
cumHazPGW <- function (N, time, eta, nu, theta) {
res <- c()
for (i in 1:N) {
res <- c(res, - 1 + (1 + (time[i] / eta) ^ nu) ^ (1 / theta))
}
res
}
get(paste("cumHaz", distribution, sep = ""))
data_stan <- function (data, model, cov_tilde = c(), cov = c(), intercept_tilde = F, intercept = F, pop.haz = "pop.haz", time = "time", obs = "cens", region = "region", adj_info = list(), ...) {
observed <- which(data[[obs]] == 1)
N <- nrow(data)
N_obs <- length(observed)
pre_computed <- list(observed = observed, N = N, N_obs = N_obs)
if (model == 1) {
data <- data_modelX(data = data, pre_computed = pre_computed, cov_tilde = cov_tilde, cov = cov, intercept_tilde = intercept_tilde, intercept = intercept, pop.haz = pop.haz, time = time, region = region, adj_info  = adj_info)
} else if (model == 2) {
data <- data_modelX(data = data, pre_computed = pre_computed, cov_tilde = cov_tilde, cov = cov, intercept_tilde = intercept_tilde, intercept = intercept, pop.haz = pop.haz, time = time, region = region, adj_info  = adj_info)
} else if (model == 3) {
data <- data_modelX(data = data, pre_computed = pre_computed, cov_tilde = cov_tilde, cov = cov, intercept_tilde = intercept_tilde, intercept = intercept, pop.haz = pop.haz, time = time, region = region, adj_info  = adj_info)
} else if (model == 4) {
data <- data_modelY(data = data, pre_computed = pre_computed,                        cov = cov,                                    intercept = intercept, pop.haz = pop.haz, time = time, region = region, adj_info  = adj_info)
} else if (model == 5) {
data <- data_modelY(data = data, pre_computed = pre_computed,                        cov = cov,                                    intercept = intercept, pop.haz = pop.haz, time = time, region = region, adj_info  = adj_info)
} else if (model == 6) {
data <- data_model6(data = data, pre_computed = pre_computed, cov_tilde = cov_tilde, cov = cov, intercept_tilde = intercept_tilde, intercept = intercept, pop.haz = pop.haz, time = time)
} else if (model == 7) {
data <- data_modelZ(data = data, pre_computed = pre_computed,                        cov = cov,                                    intercept = intercept, pop.haz = pop.haz, time = time)
} else if (model == 8) {
data <- data_modelZ(data = data, pre_computed = pre_computed,                        cov = cov,                                    intercept = intercept, pop.haz = pop.haz, time = time)
} else if (model == 9) {
data <- data_model9(data = data, pre_computed = pre_computed, cov_tilde = cov_tilde,            intercept_tilde = intercept_tilde,                        pop.haz = pop.haz, time = time)
} else {
stop("Select a valid model.")
}
data
}
design_matrix <- function (data, N, cov, intercept, ...) {
X_names <- cov
int <- data.frame()[1:N, ]
if (intercept) { int <- rep(1, N) }
X <- as.matrix(cbind(int, data[X_names]))
rownames(X) <- NULL
if (intercept) { colnames(X) <- c("int", X_names) } else { colnames(X) <- X_names }
M <- ncol(X)
list(X = X, M = M)
}
data_modelX <- function (data, pre_computed, cov_tilde, cov, intercept_tilde, intercept, pop.haz, time, region, adj_info, ...) { # Works for models 1, 2, and 3
if (length(adj_info) == 0) {
stop("Provide 'adj_info.'")
}
dm_tilde <- design_matrix(data = data, N = pre_computed$N, cov = cov_tilde, intercept = intercept_tilde)
dm <- design_matrix(data = data, N = pre_computed$N, cov = cov, intercept = intercept)
list(N = pre_computed$N, N_obs = pre_computed$N_obs, M_tilde = dm_tilde$M, M = dm$M, obs = pre_computed$observed, time = data[[time]], pop_haz = data[[pop.haz]], X_tilde = dm_tilde$X, X = dm$X, N_reg = adj_info$N_reg, N_edges = adj_info$N_edges, node1 = adj_info$node1, node2 = adj_info$node2, region = as.integer(data[[region]]))
}
data_modelY <- function (data, pre_computed, cov, intercept, pop.haz, time, region, adj_info, ...) {
if (length(adj_info) == 0) {
stop("Provide 'adj_info.'")
}
dm <- design_matrix(data = data, N = pre_computed$N, cov = cov, intercept = intercept)
list(N = pre_computed$N, N_obs = pre_computed$N_obs, M = dm$M, obs = pre_computed$observed, time = data[[time]], pop_haz = data[[pop.haz]], X = dm$X, N_reg = adj_info$N_reg, N_edges = adj_info$N_edges, node1 = adj_info$node1, node2 = adj_info$node2, region = as.integer(data[[region]]))
}
data_model6 <- function (data, pre_computed, cov_tilde, cov, intercept_tilde, intercept, pop.haz, time, ...) {
dm_tilde <- design_matrix(data = data, N = pre_computed$N, cov = cov_tilde, intercept = intercept_tilde)
dm <- design_matrix(data = data, N = pre_computed$N, cov = cov, intercept = intercept)
list(N = pre_computed$N, N_obs = pre_computed$N_obs, M_tilde = dm_tilde$M, M = dm$M, obs = pre_computed$observed, time = data[[time]], pop_haz = data[[pop.haz]], X_tilde = dm_tilde$X, X = dm$X)
}
data_modelZ <- function (data, pre_computed, cov, intercept, pop.haz, time, ...) {
dm <- design_matrix(data = data, N = pre_computed$N, cov = cov, intercept = intercept)
list(N = pre_computed$N, N_obs = pre_computed$N_obs, M = dm$M, obs = pre_computed$observed, time = data[[time]], pop_haz = data[[pop.haz]], X = dm$X)
}
data_model9 <- function (data, pre_computed, cov_tilde, intercept_tilde, pop.haz, time, ...) {
dm_tilde <- design_matrix(data = data, N = pre_computed$N, cov = cov_tilde, intercept = intercept_tilde)
list(N = pre_computed$N, N_obs = pre_computed$N_obs, M_tilde = dm_tilde$M, obs = pre_computed$observed, time = data[[time]], pop_haz = data[[pop.haz]], X_tilde = dm_tilde$X)
}
do.call(paste("cumHaz", distribution, sep = ""), params)
do.call(paste("cumHaz", distribution, sep = ""))
paste("cumHaz", distribution, sep = "")
cumHazPGW
get(cumHazPGW)
get(paste("cumHaz", distribution, sep = ""))
times <- seq(from = 0, to = 10, by = 0.1)
linear_predictor <- function (X, beta, ...) {
X %*% beta
}
linear_predictor_re <- function (N, X, beta, region, u, ...) {
res <- c()
for (i in 1:N) {
res <- c(res, u[as.integer(region[i])])
}
X %*% beta + res
}
age <- 1
sex <- 0
wbc <- 1.5
dep <- 0.5
M <- 4
X <- matrix(data = c(1, age, sex, wbc, dep), nrow = N, ncol = M)
N <- length(time)
age <- 1
sex <- 0
wbc <- 1.5
dep <- 0.5
M <- 4
X <- matrix(data = c(1, age, sex, wbc, dep), nrow = N, ncol = M)
N <- length(time)
age <- 1
sex <- 0
wbc <- 1.5
dep <- 0.5
M <- 5
X <- matrix(data = c(1, age, sex, wbc, dep), nrow = N, ncol = M)
X
N
time <- seq(from = 0, to = 10, by = 0.1)
N <- length(time)
N <- length(time)
age <- 1
sex <- 0
wbc <- 1.5
dep <- 0.5
M <- 5
X <- matrix(data = c(1, age, sex, wbc, dep), nrow = N, ncol = M)
X
X <- matrix(data = c(1, age, sex, wbc, dep), nrow = N, ncol = M, byrow = T)
X
age <- 1.5
sex <- 0
wbc <- 0.25
dep <- 0.5
M <- 5
X <- matrix(data = c(1, age, sex, wbc, dep), nrow = N, ncol = M, byrow = T)
X
fit
tail(fit)
fit[2000:2010,]
summary(fit)
summary(fit)$summary
