iter <- 3e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
# control = list(adapt_delta = 0.90, max_treedepth = 12),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
# d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, intercept_tilde = T, intercept = T, model = model)
d <- data_stan(data = data, intercept = T, model = model)
str(d)
### Stan Modeling
distribution <- "PGW" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 3e3
warmup <- 2e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
# control = list(adapt_delta = 0.90, max_treedepth = 12),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
# d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, intercept_tilde = T, intercept = T, model = model)
d <- data_stan(data = data, intercept = T, model = model)
str(d)
### Stan Modeling
distribution <- "PGW" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 8e3
warmup <- 6e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
# control = list(adapt_delta = 0.90, max_treedepth = 12),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
print(fit)
pairs(x = fit, pars = c("beta[1]", "log_eta", "log_nu", "log_theta"))
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
# d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, intercept_tilde = T, intercept = T, model = model)
d <- data_stan(data = data, intercept = T, model = model)
str(d)
### Stan Modeling
distribution <- "LN" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 10e3
warmup <- 8e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
# control = list(adapt_delta = 0.80, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
pairs(fit)
pairs(x = fit, pars = c("beta[1]", "mu", "log_sigma"))
print(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, intercept_tilde = T, intercept = T, model = model)
# d <- data_stan(data = data, intercept = T, model = model)
str(d)
### Stan Modeling
distribution <- "LL" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 10e3
warmup <- 8e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.85, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
# fit <- readRDS(file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
print(fit)
pairs(x = fit, pars = c("energy__", "lp__"), include = F)
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
pairs(x = fit, pars = c("energy__", "lp__"), include = F)
par <- fitted_data$mu
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
print(fit)
pairs(x = fit, pars = c("energy__", "lp__"), include = F)
par <- fitted_data$mu
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_chains(par = par, chains = chains, iter = iter, warmup = warmup)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
### Log Normal (LN)
# Hazard Function LN
hazLN <- function (N, time, mu, sigma, log = T, ...) {
res <- c()
for (i in 1:N) {
res <- c(res, dlnorm(time[i], mu, sigma, log = T) - plnorm(time[i], mu, sigma, lower.tail = F, log.p = T))
}
if (log) {
return(res)
} else {
return(exp(res))
}
}
# Cumulative Hazard Function LN
cumHazLN <- function (N, time, mu, sigma, ...) {
res <- c()
for (i in 1:N) {
res <- c(res, - plnorm(time[i], mu, sigma, lower.tail = F, log.p = T))
}
res
}
### Log Logistic (LL)
# Hazard Function LG
hazLL <- function (N, time, mu, sigma, log = T, ...) {
res <- c()
for (i in 1:N) {
res <- c(res, dlogis(log(time[i]), mu, sigma, log = T) - log(time[i]) - plogis(log(time[i]), mu, sigma, lower.tail = F, log.p = T))
}
if (log) {
return(res)
} else {
return(exp(res))
}
}
# Cumulative Hazard Function LL
cumHazLL <- function (N, time, mu, sigma, ...) {
res <- c()
for (i in 1:N) {
res <- c(res, - plogis(log(time[i]), mu, sigma, lower.tail = F, log.p = T))
}
res
}
### Power Generalized Weibull (PGW)
# Hazard Function PGW
hazPGW <- function (N, time, eta, nu, theta, log = T, ...) {
res <- c()
for (i in 1:N) {
res <- c(res, log(nu) - log(theta) - nu * log(eta) + (nu - 1) * log(time[i]) + ((1 / theta) - 1) * log(1 + (time[i] / eta) ^ nu))
}
if (log) {
return(res)
} else {
return(exp(res))
}
}
# Cumulative Hazard Function PGW
cumHazPGW <- function (N, time, eta, nu, theta, ...) {
res <- c()
for (i in 1:N) {
res <- c(res, - 1 + (1 + (time[i] / eta) ^ nu) ^ (1 / theta))
}
res
}
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0.025, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0.025, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
X_tilde
X
distribution
N_reg
N_samples
fitted_data
model
time <- seq(from = 0.025, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
region <- 1
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
result_processing <- function (model, fitted_data, N_samples, N_reg, distribution, time, X_tilde, X, verbose = T, ...) {
m_tilde <- check_n_cov(var = fitted_data$alpha)
m <- check_n_cov(var = fitted_data$beta)
if ((ncol(X_tilde) != m_tilde) | (ncol(X) != m)) {
stop("Provide the correct values for covariates.")
}
excHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
excCumHaz <- array(data = 0, dim = c(length(time), N_samples, N_reg))
netSur <- array(data = 0, dim = c(length(time), N_samples, N_reg))
for (j in 1:N_reg) {
if (verbose) {
cat(paste("\nRegion ", sprintf('%02d', j), "\n", sep = ""))
progressbar <- txtProgressBar(min = 1, max = N_samples, initial = 1)
}
for (i in 1:N_samples) {
lp_tilde <- compute_lp(m = m_tilde, X = X_tilde, coeff = fitted_data$alpha[i, ])
lp <- compute_lp(m = m, X = X, coeff = fitted_data$beta[i, ])
part <- add_re(model = model, lp_tilde = lp_tilde, lp = lp, random_effects = c(fitted_data$u_tilde[i, j], fitted_data$u[i, j]))
lp_tilde <- part$lp_re_tilde
lp <- part$lp_re
if (distribution == "LN") {
excHaz[, i, j] <- hazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLN(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "LL") {
excHaz[, i, j] <- hazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazLL(N = length(time), time = time * exp(lp_tilde), mu = fitted_data$mu[i], sigma = exp(fitted_data$log_sigma[i])) * exp(lp - lp_tilde)
} else if (distribution == "PGW") {
excHaz[, i, j] <- hazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = exp(fitted_data$log_theta[i]), log = F) * exp(lp)
excCumHaz[, i, j] <- cumHazPGW(N = length(time), time = time * exp(lp_tilde), eta = exp(fitted_data$log_eta[i]), nu = exp(fitted_data$log_nu[i]), theta = exp(fitted_data$log_theta[i])) * exp(lp - lp_tilde)
} else {
stop("Choose a valid distribution.")
}
netSur[, i, j] <- exp(- excCumHaz[, i, j])
if (verbose) { setTxtProgressBar(progressbar, i) }
}
if (verbose) { close(progressbar) }
}
list(excHaz = excHaz, excCumHaz = excCumHaz, netSur = netSur)
}
fitted_data <- extract(fit)
N_samples <- length(fitted_data$lp__)
time <- seq(from = 0.025, to = 4, by = 0.025)
X_tilde <- matrix(data = c(1, 1.5), nrow = length(time), ncol = 2, byrow = T)
X <- matrix(data = c(1, 1, 0.5, 1.2), nrow = length(time), ncol = 4, byrow = T)
res <- result_processing(model = model, fitted_data = fitted_data, N_samples = N_samples, N_reg = N_reg, distribution = distribution, time = time, X_tilde = X_tilde, X = X)
excHaz <- res$excHaz
excCumHaz <- res$excCumHaz
netSur <- res$netSur
# Result Visualization
region <- 1
par(family = 'LM Roman 10', mfrow = c(1, 1))
plot_summary_curve(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], region = region, ylab = "Excess Hazard", return_values = T)
plot_summary_curve(time = time, obj = excCumHaz, region = region, ylab = "Excess Cumulative Hazard", return_values = T)
plot_summary_curve(time = time, obj = netSur, region = region, return_values = T)
plot_all_regions(time = tail(time, length(time) - 1), obj = excHaz[2:length(time), , ], N_reg = N_reg, ylab = "Excess Hazard", return_values = T)
plot_all_regions(time = time, obj = excCumHaz, N_reg = N_reg, ylab = "Excess Cumulative Hazard", pos_legend = "topleft", return_values = T)
plot_all_regions(time = time, obj = netSur, N_reg = N_reg, return_values = T)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, intercept_tilde = T, intercept = T, model = model)
# d <- data_stan(data = data, intercept = T, model = model)
str(d)
### Stan Modeling
distribution <- "PGW" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 10e3
warmup <- 8e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.90, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
library(spdep)
library(rstan)
library(parallel)
rstan:::rstudio_stanc("MODELS/PGW/PGW1.stan")
library(spdep)
library(rstan)
library(parallel)
source("utils.R")
source("data_stan.R")
source("distributions.R")
source("result_processing.R")
data <- readRDS(file = "DATA/data.rds")
map  <- readRDS(file = "DATA/nwengland_map.rds")
adj <- poly2nb(pl = map)
adj <- nb2mat(neighbours = adj, style = "B")
N_reg <- nrow(adj)
nodes <- adj_quantities(adj, as.numeric(rownames(adj))) # From "utils.R"
node1 <- nodes$node1
node2 <- nodes$node2
adj_info <- list(N_reg = N_reg, N_edges = length(node1), node1 = node1, node2 = node2)
model <- 6
d <- data_stan(data = data, model = model, cov_tilde = c("age"), cov = c("sex", "wbc", "dep"), intercept_tilde = T, intercept = T, adj_info = adj_info)
# d <- data_stan(data = data, intercept_tilde = T, intercept = T, model = model)
# d <- data_stan(data = data, intercept = T, model = model)
str(d)
### Stan Modeling
distribution <- "PGW" # PGW, LN, or LL
seed <- 1
chains <- 4
iter <- 10e3
warmup <- 8e3
start_time <- Sys.time()
fit <- stan(file = paste("MODELS/", distribution, "/", distribution, model, ".stan", sep = ""),
data = d,
chains = chains,
iter = iter,
warmup = warmup,
# seed = seed,
control = list(adapt_delta = 0.85, max_treedepth = 10),
cores = getOption(x = "mc.cores", default = detectCores()))
end_time <- Sys.time()
time_taken <- end_time - start_time
time_taken
fitted_data <- extract(fit)
saveRDS(object = fit, file = paste("FITTED_MODELS/", distribution, "/", distribution, model, ".rds", sep = ""))
print(fit)
pairs(x = fit, pars = c("energy__", "lp__"), include = F)
pairs_stan
pairs.stan
class(pairs())
class(pairs
)
?pairs.stanfit
